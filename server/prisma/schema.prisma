generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String       @id @default(uuid())
  displayName   String
  handle        String?      @unique
  phoneE164     String?
  phoneVerified Boolean      @default(false)
  createdAt     DateTime     @default(now())
  credentials   Credential[]
  devices       Device[]

  // relation back to ChatMember (one entry per chat this user is in)
  chatMembers     ChatMember[]
  Message         Message[]
  MessageReaction MessageReaction[]
}

model Credential {
  credentialIdB64 String  @id
  userId          String
  publicKeyB64    String
  counter         BigInt  @default(0)
  transports      String?
  user            User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Device {
  id        String    @id @default(uuid())
  userId    String
  name      String?
  createdAt DateTime  @default(now())
  revokedAt DateTime?
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model Message {
  id        String   @id @default(cuid())
  chatId    String // e.g. "dm:<userA>|<userB>" sorted
  senderId  String // User.id
  kind      String   @default("text") // future: "image", "file", etc.
  text      String
  createdAt DateTime @default(now())

  // new stuff
  editedAt  DateTime?
  isDeleted Boolean   @default(false)
  deletedAt DateTime?

  chat            Chat              @relation(fields: [chatId], references: [id], onDelete: Cascade)
  author          User              @relation(fields: [senderId], references: [id])
  MessageReaction MessageReaction[]

  @@index([chatId, createdAt(sort: Desc)])
}

model MessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji]) // same user canâ€™t add same emoji twice
  @@index([messageId])
}

// Chat model: generic conversation container (DM or Group)
model Chat {
  // For DMs you can keep deterministic ids like "dm:<userA>|<userB>"
  // For groups you may use uuid() when creating a group chat.
  id            String    @id
  type          ChatType  @default(DM)
  name          String? // group name or optional display name
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastMessageAt DateTime?

  // relations
  members  ChatMember[]
  messages Message[]

  @@index([lastMessageAt])
}

// Join table for Chat <-> User (allows metadata per participant)
model ChatMember {
  id          String         @id @default(uuid())
  chatId      String
  userId      String
  joinedAt    DateTime       @default(now())
  role        ChatMemberRole @default(MEMBER)
  unreadCount Int            @default(0)

  chat Chat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([userId])
}

enum ChatType {
  DM
  GROUP
}

enum ChatMemberRole {
  MEMBER
  ADMIN
}
